{
  "url": "https://huggingface.co/blog/dcarpintero/design-patterns-for-building-agentic-workflows",
  "type": "webpage",
  "content": "                          Design Patterns for Building Agentic Workflows        \n  \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \n  \n \n  Back to Articles \n      Design Patterns for Building Agentic Workflows  \n   Community Article  Published\n\t\t\t\tJuly 14, 2025 \n  \n    Upvote 8 \n \n     \n   \n   \n   \n   \n   \n  +2 \n \n   \n \n \n      Diego Carpintero   dcarpintero     Follow \n  \n \n  \n   \n \n  \n \n  \n \n \n      \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n     Introduction  \n  Driven by advances in frontier models such as (i) enhanced contextual understanding, (ii) integration of multimodal capabilities, and (iii) inference-time scaling [1], AI-based applications are evolving from reactive, static assistants that respond to explicit inputs toward autonomous systems that augment our knowledge and capabilities. \n  Central to this transformation are AI Agents, systems that use a language model to interpret natural language instructions, engage with their environment, and take actions toward achieving a goal. Agents can operate with varying degrees of autonomy and collaborate with other agents and humans. Unlike traditional software that follows predetermined logic, agents adapt their behavior based on observations, past interactions, and reflection. This flexibility allows agents to proactively respond to changing conditions and coordinate across multiple systems. However, this approach introduces challenges around design, verification, scalability in production, cost management, and maintenance. \n  This article provides a comprehensive guide to building and orchestrating AI Agents that reason, plan, and act using six foundational design patterns: Evaluator-Optimizer, Context-Augmentation, Prompt-Chaining, Parallelization, Routing, and Orchestrator-Workers. \n      Table of Contents  \n   Evaluator-Optimizer Pattern \n  Context-Augmentation Pattern \n  Prompt-Chaining Workflow \n  Parallelization Workflow \n  Routing Workflow \n  Orchestrator-Workers Workflow \n  References \n       Evaluator-Optimizer Pattern  \n  This pattern draws inspiration from self-reflection , a common approach in problem-solving that involves introspective examination of thoughts, actions, and experiences to gain insight and improve results. The Evaluator-Optimizer pattern [2] [3] [4] applies a similar iterative refinement to LLM response generation. \n  This enables LLMs to enhance their responses through systematic feedback and refinement. Rather than accepting first-attempt outputs, it establishes a process to self-reflect on past actions and implement targeted improvements. \n      Architecture  \n  Its name reflects its core architecture: the Evaluator provides a critical assessment of the output, while the Generator / Optimizer transforms such actionable feedback and guidance into concrete improvements. The pattern implements the following workflow: \n    Evaluator-Optimizer Pattern    Generation : The LLM generates an initial response, or completes a task using its standard capabilities. This first attempt serves as the baseline output, though it may contain errors, lack clarity, or miss relevant facts. \n  Reflection - Evaluator : The same LLM (or a specialized evaluator model) examines the generated output and systematically evaluates it against given requirements, guidelines, or external observations. \n  Refinement - Optimizer : Translates reflective feedback into concrete improvements. This might involve restructuring content, adding missing elements, or correcting identified issues. \n  Iteration : The process repeats until the output meets predetermined quality criteria or stopping conditions. Each iteration can reveal new improvement opportunities. \n   These steps can be carried out by a single LLM at each stage, or distributed across specialized LLMs optimized for evaluation versus generation tasks. \n      Use Cases  \n  The intended task typically requires to generate a high-quality output characterized by completeness, correctness, and accuracy: \n   Critical Software Code Generation : Generating code, validating it against test cases, debugging errors, and refining for style and efficiency. \n  Writing : Improving linguistic flow, reducing bias, and ensuring alignment with a targeted audience. \n  Analytical Work : Complex tasks requiring nuanced judgment and multiple perspectives. \n  Trustworthiness : Cross-referencing generated content against search engines or trusted knowledge bases to ensure accuracy. \n       Considerations  \n   Balancing Cost-Benefit : The most critical implementation decision involves determining when quality gains justify additional computational costs. Each iteration increases both latency and token usage, making it essential to define clear criteria for when this approach adds value. \n  Effective Stopping Criteria : Poorly designed stopping conditions can trap systems in suboptimal states - either terminating too early and missing obvious improvements, or making marginal refinements indefinitely. Robust implementations incorporate multiple safeguards:  Quality gates (such as code passing test suites) \n  Maximum iteration boundaries \n  Token budget constraints \n  Similarity checks to identify when successive versions show minimal, meaningful changes \n   \n  Actionable Feedback : The feedback provided provided by the evaluator must be specific and concrete to guide the Generator / Optimizer. \n       Context-Augmentation Pattern  \n  LLM capabilities are static and limited by training data. The Context Augmentation Pattern address this limitation by dynamically expanding the LLM context beyond pre-trained knowledge. Building upon function-calling patterns [5] [6] [7], it enables LLMs to connect and work with tools and external systems. These interactions have been standardized by the Model Context Protocol [8], making the pattern reliable for production applications. Its primary advantages are flexibility and extensibility, as new capabilities can be easily added to a model. \n      Architecture  \n    Context-Augmentation Pattern    Requirements Identification : The LLM analyzes the intended task and identifies needs that exceed its internal capabilities. \n  Resource Selection : From available resources, the model selects appropriate tools, systems or data sources (based on the specific need). This might involve choosing between a calculator for mathematical operations, a web search, or a database query. \n  Context Augmentation : The LLM interacts with tools and external systems to integrate additional information into its working context. This step fundamentally expands the model's knowledge for the current task. \n  Synthesis : The augmented context enables the model to provide responses that combine its reasoning capabilities with task-specific information. \n  Orchestration : Complex tasks may require multiple interactions with resources, wherein each result informs subsequent resource selection and usage. \n       Use Cases  \n   Real-Time Information : Accessing data that changes frequently and was not available during training such as weather conditions, stock market data, and recent news articles. \n  Computational Tasks : Performing complex mathematical operations or data analysis requiring precision beyond what language models can provide. \n  Knowledge Integration : Searching company documentation, accessing customer support databases, or querying technical specifications. \n  Device Control : Managing IoT ecosystems such as smart home devices and industrial sensors. \n  Enterprise Orchestration : Integrating specialized services for business tasks such as payment processing, communication management, and software development workflows. \n       Considerations  \n   Security and Access Control : Tool integration and interactions with MCP Servers introduce significant security risks. Robust implementations require careful authentication, authorization, and sandboxing to prevent unintended access to sensitive systems or data. \n  Reliability and Error Handling : External dependencies can fail or return unexpected results. This requires fallback strategies and error recovery mechanisms. \n  Operational Challenges : Resource selection strategies become critical with multiple available resources \u2014 poor choices might lead to inefficient workflows and suboptimal results. Additionally, API calls and third-party services can introduce additional costs. \n  Technical Constraints : Context window limitations necessitate balancing information retrieval with context management, potentially requiring summarization or selective retention. \n       Prompt-Chaining Workflow  \n  The Prompt-Chaining-Workflow [9] evolved from Chain-Of-Thought prompting (CoT) by applying decomposition , where complex tasks are broken down into smaller, manageable subtasks. An AI Engineer generates a sequence of specialized prompts for each subtask, where the output of one prompt becomes the input for the next, thus aggregating the gains from each step. \n  Beyond achieving better performance, prompt chaining enhances the transparency, controllability, and flexibility of LLM applications. Moreover, this structured approach enables easier debugging of model responses, targeted performance improvements at specific stages within the workflow, and support for different paths. \n      Architecture  \n    Prompt-Chaining Workflow    Task Decomposition : A complex task is analyzed and broken down into logical subtasks. This decomposition can be done manually or with LLM assistance using meta-prompting techniques. \n  Sequential Processing : Each subtask is handled by a specialized prompt within a dedicated LLM call, allowing focused attention on the specific subtask. \n  Information Handoff : Outputs from each prompt are structured to provide the necessary context for the next step. This may involve data transformation, formatting, or filtering to ensure clean transitions between stages. \n  Context Preservation : The chain maintains relevant context across steps while avoiding information overload. Each step should receive only the information necessary for its specific task, preventing context dilution. \n  Gates : Conditional checkpoints can be integrated between steps to validate outputs, route workflows based on content analysis, or terminate the chain when certain conditions are met. \n       Use Cases  \n   Documents Analysis : Breaking down large documents into manageable tasks such as keyword extraction, summarization, and classification. \n  Content Creation : Including tasks such as drafting, editing, formatting, and translation. \n  Research Assistance : For systematic evaluation of hypotheses, results analysis, and literature review. \n       Considerations  \n   Balancing Cost-Benefit : Prompt chaining can produce more favorable outcomes compared to single-prompt approaches. However, this improvement comes with increased computational costs and latency. \n  Selective Context Management : Outputs from previous steps must contain only the information necessary for the next task, as verbosity or irrelevant information can exceed context window limits and disrupt subsequent steps. \n  Intermediate Validations : Mistakes can cascade and compound through the entire chain. To mitigate these errors, it is recommended to implement quality gates before passing to the next step, this might include:  Programmatic Checks (e.g., content length, format validation) \n  LLM-based output validation (e.g., for factual accuracy) \n  Confidence scoring \n   \n  Error Handling : Failing outputs can be handled with:  Retry \n  Re-prompting including the error details \n  Fallback Mechanisms such as logging and termination, or routing . \n   \n       Parallelization Workflow  \n  Following the divide and conquer approach, the LLM workload is distributed among agents to process tasks concurrently. In practice, this workflow is implemented in two variations to improve accuracy and/or speed up completion [10]: \n   Sectioning: Breaking a task into independent subtasks that run in parallel. \n  Voting: Running the same task multiple times to obtain diverse outputs. \n       Architecture  \n    Parallelization Workflow    Task Decomposition : Analyzes the incoming task and identifies independent subtasks that can be processed simultaneously. \n  Parallel Processing: Subtasks are allocated and processed by workers, each receiving specific instructions, context, and success criteria. \n  Aggregation: Results from all workers are aggregated through various synthesis methods to produce a coherent final output. \n       Use Cases  \n      Sectioning  \n   Content Guardrails : One model instance processes user queries while another screens them for inappropriate content. \n  Automated Evals : Multiple LLM calls evaluate different aspects of model performance on given prompts. \n  Document Analysis : Assigning document sections like chapters to different workers, then synthesizing or aggregating the outputs. \n       Voting  \n   Code Security Review : Different prompts review and flag code for vulnerabilities, with multiple perspectives increasing detection accuracy. \n  Content Moderation : Multiple prompts evaluate different aspects of the input or require different vote thresholds to balance false positives and negatives. \n       Considerations  \n   Task Independence : Ensuring subtasks are truly independent. Tasks with sequential dependencies are better suited for prompt chaining patterns. \n  Decomposition Strategy :  Sectioning/Sharding : Splitting large inputs like a long document or a dataset into smaller chunks, with each chunk being processed in parallel \n  Aspect-Based : For tasks requiring analysis of multiple independent facets \n  Identical Tasks for Diversity or Voting : Running the same core task multiple times with varied prompts or models with the goal of achieving a more reliable result \n   \n  Aggregation Strategy : After the parallel tasks are completed, outputs can be combined using methods like:  Concatenation : Joining the outputs together, like appending individual chapter summaries \n  Comparison and Selection : Choosing among alternative outputs for the same task \n  Voting/Majority Rule : Consensus-based decision making. When multiple agents independently perform the same task, the most frequently occurring output is chosen as the final answer, boosting accuracy. \n  Synthesizer : A dedicated LLM creates a coherent final response from diverse outputs \n   \n       Routing Workflow  \n  Routing evaluates an input and delegates it to a specialized function, tool, or sub-agent. This workflow enables: separation of concerns, resource optimization, flexibility, and scalability. \n      Architecture  \n  It operates through a two-step architecture: task classification and task dispatch. \n    Routing Workflow    Task Classification : The system analyzes incoming requests to determine their type, category, intent, or complexity level. It can be implemented through various methods: \n   Rule-based : Using predefined logic, keyword matching, or conditional statements \n  LLM-based classification : Leveraging contextual understanding for more nuanced categorization \n  Hybrid methods : Combining both approaches \n   \n  Task Dispatch : Based on the classification results, the system routes the input. In practice, the processing path selection depends on: \n   Agent specialization and expertise \n  Resource requirements \n  Performance characteristics (speed, cost, accuracy) \n  Current system load and capacity \n   \n       Use Cases  \n   E-Commerce / Customer Service : Automatically directing different types of user requests into different downstream processes, prompts, and tools. \n  Workload Branching : Distributing inputs based on type and complexity, routing straightforward queries to lightweight models and complex questions to more capable models to optimize cost and speed. \n  Multi-Domain Q&A : Directing domain-specific questions to specialized knowledge agents. \n       Considerations  \n   Classification Accuracy : The workflow's effectiveness depends entirely on accurate input classification. If a task is misclassified, it might be sent to the wrong agent, leading to inefficiency or incorrect results. \n  Specialization Balance : While specialization improves performance for specific tasks, the system should maintain appropriate generalization and flexibility to ensure that edge cases and novel inputs find their way to the most appropriate processing path. \n  Dynamic Routing : Advanced implementations incorporate real-time system state into routing decisions, considering factors such as agent availability, current workload, and performance metrics. \n  Scalability and Maintenance : As systems grow, the number of potential routing paths might increase significantly. \n       Orchestrator-Workers Workflow  \n  In this workflow, a central LLM dynamically decomposes tasks, delegates them to worker agents, and synthesizes their outputs into coherent results. \n      Architecture  \n  The Orchestrator is the lead agent providing intelligent coordination and synthesis, while the Workers execute specialized subtasks. \n    Orchestrator-Workers Workflow    Task Analysis : The Orchestrator analyzes incoming requests in real-time, dynamically determining necessary subtasks rather than following pre-defined workflows. This  considers task complexity, available resources, and optimal decomposition. \n  Delegation : The Orchestrator selects appropriate workers to delegate subtasks, providing each worker with clear objectives, output formats, and tool guidance. \n  Result Synthesis : The Orchestrator collects outputs from all workers and synthesizes them into a unified, coherent response. \n       Use Cases  \n  This workflow is well-suited for scenarios where subtasks are not pre-defined, but determined dynamically by the Orchestrator based on the input, such as: \n   Business Intelligence : Requiring information gathering from multiple sources, synthesis, and generation of reports. This workflow can adapt to query complexity and scale from simple fact-finding to comprehensive analysis. \n  Software Development : Coding tasks where the Orchestrator can dynamically determine which files need modification, and coordinate specialized sub-agents for code generation, testing, debugging, and documentation. \n       Considerations  \n   Orchestration Effectiveness : The orchestrator must handle complex task decomposition and worker selection. This can create bottlenecks and requires careful resource management, control loops, and error handling to avoid single points of failure in task distribution and orchestrator-worker communication. \n  Complexity Management : Production systems often require hundreds of conversation turns, necessitating context compression, external memory systems, and observability mechanisms. \n  Evaluation Challenges : Multi-agent systems require specialized evaluation approaches, including small-scale testing for rapid iteration and LLM-as-a-judge evaluation for complex requests. \n       References  \n   [1] Balachandran, et al. 2025. Inference-Time Scaling for Complex Tasks: Where We Stand and What Lies Ahead . arxiv:2504.00294 . \n  [2] Madaan, et al. 2023. Self-Refine: Iterative Refinement with Self-Feedback . arxiv:2303.17651 . \n  [3] Shinn, et al. 2023. Reflexion: Language Agents with Verbal Reinforcement Learning . arxiv:2303.11366 \n  [4] Gou, et al. 2024. CRITIC: Large Language Models Can Self-Correct with Tool-Interactive Critiquing . arxiv:2305.11738 \n  [5] Patil, et al. 2023. Gorilla: Large Language Model Connected with Massive APIs . arxiv:2305.15334 \n  [6] Yang, et al. 2023. MM-REACT: Prompting ChatGPT for Multimodal Reasoning and Action . arxiv:2303.11381 \n  [7] Gao, et al. 2024. Efficient Tool Use with Chain-of-Abstraction Reasoning . arxiv:2401.17464 \n  [8] Anthropic. 2024. Model Context Protocol . anthropic:mcp \n  [9] Wu, et al. 2022. AI Chains: Transparent and Controllable Human-AI Interaction by Chaining Large Language Model Prompts . dl.acm:3491102.3517582 \n  [10] Anthropic. 2024. Building effective agents . anthropic:agents \n  [11] Cheng, et al. 2024. Exploring Large Language Model based Intelligent Agents: Definitions, Methods, and Prospects . arxiv:2401.03428 \n  [12] Anthropic. 2025. How we built our multi-agent research system . anthropic:multi-agent-research \n   \n \n  Community \n  \n  Edit Preview \n  \n \n     \n  \n   Upload images, audio, and videos by dragging in the text input, pasting, or clicking here . \n  Tap or paste here to upload images \n  \n  \n   Comment  \u00b7  Sign up or log in to comment \n \n \n \n \n \n \n    Upvote 8 \n \n     \n   \n   \n   \n   \n   \n   \n   \n  \n \n   \n \n \n \n  \n \n \n \n \n      ",
  "title": "Design Patterns for Building Agentic Workflows",
  "content_type": "text/html; charset=utf-8"
}