{
  "url": "https://dev.to/focused_dot_io/migrating-classic-langchain-agents-to-langgraph-a-how-to-nea",
  "type": "webpage",
  "content": "    Migrating Classic LangChain Agents to LangGraph a How To - DEV Community                                                         \n   \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n     \n  \n \n \n \n \n \n    \n   \n  \n  \n  \n  \n    \n                                Add reaction          Like        Unicorn        Exploding Head        Raised Hands        Fire   \n  \n  \n           Jump to Comments          Save         Boost     \n  \n    More...      Copy link  Copy link     Copied to Clipboard \n  \n   Share to X  Share to LinkedIn  Share to Facebook  Share to Mastodon  \n     Share Post via...   Report Abuse  \n  \n  \n  \n       \n \n \n \n \n \n \n \n \n    Takeaway : You can swap a legacy AgentExecutor for a LangGraph node in a single commit. The payoff is lower overhead, deterministic routing, and native persistence. \n    WHY MIGRATE NOW? \n  LangChain announced that with LangChain 0.2 the original agent helpers ( initialize_agent , AgentExecutor ) are deprecated and will only receive critical fixes. LangChain recommends moving to LangGraph\u2019s node\u2011based approach for better control flow, built\u2011in persistence, and the ability to use multi\u2011actor workflows. \n    WHAT CHANGED IN LANGCHAIN 0.2 AND LATER? \n  Legacy pattern (langchain < 0.2) versus current pattern (langchain 0.2 or newer): \n  \u2022 Agent entry point \u2013 legacy: initialize_agent; current: graph node created with LangGraph helpers. \u2022 Configuration \u2013 legacy: many function kwargs that are hard to extend; current: typed graph state and composable nodes. \u2022 Persistence \u2013 legacy: DIY pickling or a custom DB; current: checkpoint helpers built into LangGraph. \ufffc \u2022 Deprecation status \u2013 legacy helpers are deprecated; the LangGraph approach is the long\u2011term, fully supported path. \n    CODE DIFF: FROM initialize_agent TO A LANGGRAPH NODE \n  Below is a minimal ReAct agent that calls a calculator tool\u2014first the legacy way, then the LangGraph way. \n  Before\u00a0(legacy agent)  \n   from  langchain.agents  import  AgentExecutor ,  AgentType ,  initialize_agent ,  load_tools  from  langchain.chat_models  import  ChatOpenAI  from  langchain_core.tools  import  tool  @tool  def  capitalize ( text :  str )  ->  str :  \"\"\" Capitalize the text. \"\"\"  return  text . upper ()  llm  =  ChatOpenAI ( model = \" gpt-4o-mini \" )  agent  =  initialize_agent (  [ capitalize ],  llm ,  agent = AgentType . ZERO_SHOT_REACT_DESCRIPTION ,  verbose = True ,  )  response  =  agent . run ( \" can you capitalize this text: hello world \" )  print ( response )     Enter fullscreen mode    Exit fullscreen mode    \n  \n  \n  After\u00a0(LangGraph)  \n   from  langgraph.prebuilt  import  create_react_agent  from  langgraph.graph  import  END ,  StateGraph  from  langchain_openai  import  ChatOpenAI  from  langchain.tools  import  Calculator  class  State ( TypedDict ):  messages :  Annotated [ list ,  add_messages ]  @tool  def  capitalize ( text :  str )  ->  str :  \"\"\" Capitalize the text. \"\"\"  print ( f \" Capitalizing text: { text } \" )  return  text . upper ()  llm  =  ChatOpenAI ( model = \" gpt-4o-mini \" )  tools  =  [ capitalize ]     Enter fullscreen mode    Exit fullscreen mode    \n  \n  \n    Create the ReAct agent node \n   agent_node  =  create_react_agent ( llm ,  tools )     Enter fullscreen mode    Exit fullscreen mode    \n  \n  \n    Build a simple single\u2011node graph \n   graph  =  StateGraph ( State )  graph . add_node ( \" react_agent \" ,  agent_node )  graph . set_entry_point ( \" react_agent \" )  graph . add_edge ( \" react_agent \" ,  END )  agent_executor  =  graph . compile ()  response  =  agent_executor . invoke ({ \" messages \" :  [{ \" role \" :  \" user \" ,  \" content \" :  \" can you capitalize this text: hello world \" }]})  print ( response [ \" messages \" ][ - 1 ]. content )     Enter fullscreen mode    Exit fullscreen mode    \n  \n  \n  The functional behavior is identical, but you gain an explicit state object, the ability to add router or guardrail nodes later without refactoring the agent itself, and full compatibility with LangGraph\u2019s checkpoint and observability APIs. \ufffc \ufffc \n    UPDATING TESTS AND CALLBACKS \n  Unit tests with Pytest and LangSmith  \n   rom  graph  import  agent_executor  def  test_capitalize_text ():  result  =  agent_executor . invoke ({  \" messages \" :  [{ \" role \" :  \" user \" ,  \" content \" :  \" can you capitalize this text: hello world \" }]  })  assert  \" HELLO WORLD \"  in  result [ \" messages \" ][ - 1 ]. content     Enter fullscreen mode    Exit fullscreen mode    \n  \n  \n  For richer coverage, use LangSmith\u2019s pytest plugin to log run trees and score outputs with metrics instead of brittle string matches. \ufffc \ufffc \n  Callbacks If you previously passed callbacks into initialize_agent(..., callbacks=[StdOutCallbackHandler()]), move them to the graph compile step (or to individual nodes for fine\u2011grained tracing):  \n   from  langchain_core.callbacks.base  import  BaseCallbackHandler  class  PrintCallbackHandler ( BaseCallbackHandler ):  def  on_llm_start ( self ,  serialized :  dict [ str ,  any ],  prompts :  list [ str ],  ** kwargs :  any )  ->  None :  print ( f \" LLM start: { prompts } \" )  response  =  agent_executor . invoke ({ \" messages \" :  [{ \" role \" :  \" user \" ,  \" content \" :  \" can you capitalize this text: hello world \" }]},  { \" callbacks \" :  [ PrintCallbackHandler ()]})     Enter fullscreen mode    Exit fullscreen mode    \n  \n  \n    PRODUCTION ROLLOUT CHECKLIST \n   Freeze versions: pin langchain>=0.2,<0.3, then move to 0.3 and the latest stable langgraph. \n  Refactor imports: search\u2011and\u2011replace initialize_agent( with create_react_agent(. \n  Compile once: cache the compiled graph (agent_executor) at application start to avoid cold\u2011start overhead. \n  State schema: define a TypedDict or Pydantic model for your graph state to catch breaking changes early. \n  Health probes: invoke the graph with {\u201cmessage\u201d: {role: {\u201cuser\u201d: \u201cping\u201d}}} and expect \"pong\" so orchestration platforms detect failures. \n  Checkpoint storage: configure S3, Redis, or SQLite persistence before rolling to production if your flows exceed a single request. \ufffc \n  Observability: enable LANGCHAIN_TRACING_V2=true and send traces to LangSmith. \n  Canary deploy: route a slice of traffic to the new executor and compare latency and error rate against the legacy path. \n  Retire legacy code: delete deprecated agent imports when metrics hit parity. \n  Document the graph: export a GraphViz diagram and commit it so new teammates can visualize the flow. \n     FINAL WORD \n  Upgrading to LangGraph is not a risky rewrite; it is a surgical swap that positions your agent for reliable scale, granular observability, and future multi\u2011actor magic. Make the jump today and own the graph\u2014before the graph owns you. \n  \n  \n  \n   \n \n \n \n  \n   \n             \n     \n   \n  Create template  Templates let you quickly answer FAQs or store snippets for re-use. \n  \n  \n   Submit  Preview  Dismiss  \n  \n  \n    \n  \n    \n      Are you sure you want to hide this comment? It will become hidden in your post, but will still be visible via the comment's permalink . \n    Hide child comments as well \n    Confirm  \n  \n   For further actions, you may consider blocking this person and/or reporting abuse \n  \n    \n  \n   \n           Focused   \n   Follow  \n  We help you welcome change - not fear it! \n   Build With Focus We\u2019ll sit down with your team and build side-by side. \n  Deploy With Focus The most expensive app you\u2019ll build is the one that\u2019s never deployed. \n  Learn With Focus Scale knowledge across teams of 10 to 100. \n  \n   Work With Focus  \n  \n   \n   3 Things I\u2019ve Learned While Implementing My First Multi Agent Architecture  # ai  # webdev  # learning  # agentaichallenge  \n   Customizing Memory in LangGraph Agents for Better Conversations  # ai  # langchain  # programming  # python  \n   Why Big Classes Get Bigger: Understanding Preferential Attachment in Your Code  # architecture  # coding  # programming  # systemdesign  \n   \n  \n  \n  \n   \n  \n  \n  \n      \n  \n  \n  \n  \n  \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  \n        We're a place where coders share, stay up-to-date and grow their careers. \n  \n   Log in  Create account  \n  \n  \n   \n        \n    ",
  "title": "Migrating Classic LangChain Agents to LangGraph a How To - DEV Community",
  "content_type": "text/html; charset=utf-8"
}